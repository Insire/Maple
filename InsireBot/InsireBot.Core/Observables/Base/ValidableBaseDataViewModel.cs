using FluentValidation;
using FluentValidation.Results;
using Maple.Data;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Maple.Core
{
    public abstract class ValidableBaseDataViewModel<TViewModel, TModel> : BaseDataViewModel<TViewModel, TModel>, INotifyDataErrorInfo
        where TViewModel : BaseDataViewModel<TViewModel, TModel>, ISequence
        where TModel : BaseObject
    {
        private bool _skipValidation;
        private IValidator<TViewModel> _validator;

        protected readonly IDictionary<string, ValidationResult> _errors;

        public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;
        public bool HasErrors => _errors.Any(p => !p.Value.IsValid);

        public IEnumerable GetErrors(string propertyName)
        {
            if (string.IsNullOrEmpty(propertyName))
                return _errors.SelectMany(p => p.Value.Errors.Select(f => f.ErrorMessage));

            if (_errors?.ContainsKey(propertyName) != true)
                return Enumerable.Empty<string>();

            return _errors[propertyName].Errors.Select(p => p.ErrorMessage);
        }

        protected void OnErrorsChanged(string propertyName)
        {
            ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
        }

        protected ValidableBaseDataViewModel()
            : base()
        {
            _skipValidation = true;
            _errors = new Dictionary<string, ValidationResult>();
        }

        protected ValidableBaseDataViewModel(TModel model, IValidator<TViewModel> validator)
            : this()
        {
            _validator = validator ?? throw new ArgumentNullException(nameof(validator)); //order is important in this case
            Model = model ?? throw new ArgumentNullException(nameof(model));

            _skipValidation = false;
        }

        /// <summary>
        /// Validates this instance.
        /// </summary>
        /// <autogeneratedoc />
        public virtual void Validate()
        {
            var result = _validator.Validate(this);
            // TODO figure out how i can get update the errors dictionary from this
            // aka get propertyNames from the validator

            // run validation on all properties and rules
        }

        /// <summary>
        /// Validates the specified property name.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="System.ArgumentNullException"></exception>
        /// <autogeneratedoc />
        public virtual void Validate([CallerMemberName] string propertyName = null)
        {
            if (_skipValidation)
                return;

            if (string.IsNullOrEmpty(propertyName))
                throw new ArgumentNullException(propertyName);

            AddOrUpdateValidationResults(_validator.Validate(this, propertyName), propertyName);
        }

        /// <summary>
        /// Called when [property changed].
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <autogeneratedoc />
        protected override void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            base.OnPropertyChanged(propertyName);

            if (_skipValidation)
                return;

            AddOrUpdateValidationResults(_validator.Validate(this, propertyName), propertyName);
        }

        private void AddOrUpdateValidationResults(ValidationResult result, string propertyName)
        {
            if (_skipValidation)
                return;

            var hadErrors = false;

            if (_errors.ContainsKey(propertyName))
            {
                hadErrors = _errors[propertyName].Errors.Count > 0;

                _errors[propertyName].Errors.Clear();
                _errors[propertyName] = result;
            }
            else
                _errors.Add(propertyName, result);

            if (hadErrors != result.IsValid)
                return;

            OnErrorsChanged(propertyName);

            if (Debugger.IsAttached)
            {
                foreach (var item in _errors[propertyName].Errors)
                    Debug.WriteLine(item);
            }
        }
    }
}
