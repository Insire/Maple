using FluentValidation;
using FluentValidation.Results;
using Maple.Data;
using Maple.Localization.Properties;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;

namespace Maple.Core
{
    public abstract class ValidableBaseDataViewModel<TViewModel, TModel> : BaseDataViewModel<TViewModel, TModel>, INotifyDataErrorInfo
        where TViewModel : BaseDataViewModel<TViewModel, TModel>, ISequence
        where TModel : BaseObject
    {
        private bool _skipValidation;

        protected IValidator<TViewModel> Validator { get; }
        protected IDictionary<string, ValidationResult> Errors { get; }

        public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

        public bool HasErrors => Errors.Any(p => !p.Value.IsValid);

        private ValidableBaseDataViewModel(IMessenger messenger)
            : base(messenger)
        {
            _skipValidation = true;
            Errors = new Dictionary<string, ValidationResult>();
        }

        protected ValidableBaseDataViewModel(TModel model, IValidator<TViewModel> validator, IMessenger messenger)
            : this(messenger)
        {
            Validator = validator ?? throw new ArgumentNullException(nameof(validator), $"{nameof(validator)} {Resources.IsRequired}"); //order is important in this case
            Model = model ?? throw new ArgumentNullException(nameof(model), $"{nameof(model)} {Resources.IsRequired}");
        }

        public virtual void Validate()
        {
            _skipValidation = false;
            var result = Validator.Validate(this);
            // TODO figure out how i can get update the errors dictionary from this
            // aka get propertyNames from the validator

            // run validation on all properties and rules
        }

        public IEnumerable GetErrors(string propertyName)
        {
            if (string.IsNullOrEmpty(propertyName))
                return Errors.SelectMany(p => p.Value.Errors.Select(f => f.ErrorMessage));

            if (Errors?.ContainsKey(propertyName) != true)
                return Enumerable.Empty<string>();

            return Errors[propertyName].Errors.Select(p => p.ErrorMessage);
        }

        /// <summary>
        /// Validates the specified property name.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <exception cref="System.ArgumentNullException"></exception>
        /// <autogeneratedoc />
        public virtual void Validate([CallerMemberName] string propertyName = null)
        {
            if (_skipValidation)
                return;

            if (string.IsNullOrEmpty(propertyName))
                throw new ArgumentNullException(propertyName, $"{nameof(propertyName)} {Resources.IsRequired}");

            AddOrUpdateValidationResults(Validator.Validate(this, propertyName), propertyName);
        }

        protected override void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            base.OnPropertyChanged(propertyName);

            if (_skipValidation)
                return;

            AddOrUpdateValidationResults(Validator.Validate(this, propertyName), propertyName);
        }

        private void AddOrUpdateValidationResults(ValidationResult result, string propertyName)
        {
            if (_skipValidation)
                return;

            var hadErrors = false;

            if (Errors.ContainsKey(propertyName))
            {
                hadErrors = Errors[propertyName].Errors.Count > 0;

                Errors[propertyName].Errors.Clear();
                Errors[propertyName] = result;
            }
            else
                Errors.Add(propertyName, result);

            if (hadErrors != result.IsValid)
                return;

            OnErrorsChanged(propertyName);

            if (Debugger.IsAttached)
            {
                foreach (var item in Errors[propertyName].Errors)
                    Debug.WriteLine(item);
            }
        }

        protected void OnErrorsChanged(string propertyName)
        {
            ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
        }
    }
}
